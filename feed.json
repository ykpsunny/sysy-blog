{"title":"Sunny的博客","description":"用于提升锻炼自己的博客","language":"","link":"//sysy.site","pubDate":"Mon, 06 Apr 2020 06:21:00 GMT","lastBuildDate":"Mon, 06 Apr 2020 15:33:41 GMT","generator":"hexo-generator-json-feed","webMaster":"Sunny","items":[{"title":"immer的使用","link":"//sysy.site/2020/04/06/immer/","description":"JS 里面的变量类型可以分为 基本类型 和 引用类型 ，在 JS 中使用引用类型数据时需要格外的注意引用问题，不然，一不小心就踩坑了！！！ 1234let a = 10let b = ab = 5console.log(a === b) // ? 上面的 **a** 跟 **b** 会相对吗，因为是基本型数据，所以肯定是 false 那我们改成引用类型呢？ 123456let obj = &#123; a: 10&#125;let obj1 = objobj1.a = 5console.log(obj.a) // ? 此时应该打印多少？10 还是 5，答案是 5，why？我刚刚明明修改的是 obj1，为什么会影响到 obj 呢，因为对象赋值本质上是把地址赋值给 obj1，并不是把 obj 中的内容赋值给 obj1，这样做是为了节约内存，但是在实际的生产过程当中这样的设计会引发无穷无尽的问题，所以我们要解决这种相互引用的问题。 为了解决互相引用的问题ES6提供了 Object.assign，展开运算符 ... Object.assign 与 ... 运算符 1234567891011let obj = &#123; a: &#123; b: 'b' &#125;&#125;let obj1 = &#123; ...obj&#125;// let obj1 = Object.assign(&#123;&#125;, obj)obj1.a.b = 10console.log(obj.a.b) // ？ 此处打印的是 10，因为 ... 或 Object.assign 只做了浅层拷贝，对于深层的内容本质上还是相同的引用，所以修改 obj1.a.b 还是会影响到 obj，所以只能深层拷贝，彻底解决引用问题 深拷贝 — deepClone 深拷贝，顾名思义就是，在遍历赋值的过程中，如果遇到了引用类型的值，就递归创建一个新的数据。 123456789101112131415161718192021const deepClone = (origin) =&gt; &#123; let target = Array.isArray(origin) ? [] : &#123;&#125; for (let prop in origin) &#123; if (origin.hasOwnProperty(prop)) &#123; if (origin[prop] !== null &amp;&amp; typeof origin[prop] === 'object') &#123; target[prop] = deepClone(origin[prop]) &#125; else &#123; target[prop] = origin[prop] &#125; &#125; &#125; return target&#125;let obj = &#123; a: &#123; b: 'b' &#125;&#125;let obj1 = deepClone(obj)obj1.a.b = 10console.log(obj.a.b) // 'b' 上面的这个 deepClone 可以满足简单的需求，但是真正在生产工作中，我们需要考虑非常多的因素。 比如：对象之间的循环引用问题，值为 Symbol 类型的数据时，原型链上的内容如何处理，等一系列问题。 因为有太多不确定因素，所以在真正的生产环境中，还是推荐大家使用开源工具库 loadsh 中的 cloneDeep 。 深拷贝的问题在于给每一个数据都做了拷贝，会浪费内存，所以还是要借助 immer 或 immutable-js 来做性能优化。 immer immer 是一个以 ES6 中 Proxy 为核心的 immutable 库，几乎以最小的成本 (压缩之后仅 3KB) 实现了 js 的不可变数据结构，简单易用 (API 不多，而且使用原生的数据类型)，满足了我们对JS不可变数据结构的需求。 GitHub 地址: https://immerjs.github.io/immer 安装: yarn: yarn add immer –save npm: npm i immer –save 使用: 用法一: 1234567891011121314151617import produce from 'immer'let obj = &#123; a: &#123; b: 'b' &#125; c: &#123; text: 'c' &#125;&#125;let obj1 = produce(obj, (draftState) =&gt; &#123; draftState.a.b = 10&#125;)console.log(obj.a.b) // 'b'console.log(obj1.a.b) // 10console.log(obj.c === obj1.c) // true 通过上面的用法我们能发现，所有具有副作用的逻辑都可以放进 produce 的第二个参数的函数内部进行处理。在这个函数内部对数据进行任何操作，都不会对原对象产生任何影响。 在不影响的同时，未修改的部分，还保持着相应的关联。 用法二: 12345678910111213141516import produce from 'immer'let obj = &#123; a: &#123; b: 'b' &#125;&#125;const producer = produce(draftState =&gt; &#123; draftState.a.b = 10;&#125;)let obj1 = producer(obj)console.log(obj.a.b) // 'b'console.log(obj1.a.b) // 10console.log(obj.c === obj1.c) // true 先传入一个要操作对象的函数，利用高阶函数的特点，返回一个生产者，然后传入需要修改的对象即可。 在 React 中使用 有如下数据: 12345678910111213this.state = &#123; userList: [&#123; id: 0, name: \"zs\", age: 18 &#125;, &#123; id: 1, name: \"ls\", age: 20 &#125; ]&#125; 需求：给 userList 的第最后一个用户年龄加一岁 不使用 immer 实现: 123456789let &#123; userList&#125; = this.statelet users = userList.slice(), lastIndex = users.length - 1users[lastIndex].age++this.setState(&#123; userList: users&#125;) 使用 immer 之后: 1234this.setState(produce(state =&gt; &#123; let lastIndex = state.userList.length - 1 state.userList[lastIndex].age++&#125;)) 是不是感觉代码量瞬间少了很多，阅读起来舒服了很多，而且更易于阅读了。 React Hooks 中使用 12345678const [data, setData] = useState(&#123; a: 'a', b: 'b', c: &#123; d: 'd', f: 'f' &#125;&#125;) 需求: 把对象 c 里的 d 的值改为 10 不使用 immer 实现: 123456789setData(state =&gt; &#123; return &#123; ...state, c: &#123; ...state.c, d: 10 &#125; &#125;;&#125;) 使用 immer 之后: 123456setData( produce(state =&gt; &#123; state.c.d = 10; return state; &#125;)) immer + React Hooks 使用起来真的很顺手，而且更易于阅读，目前我就一直在用。 React reducer 中使用 不使用 immer: 12345678910111213141516171819const reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return &#123; ...state, count: state.count++ &#125; break; case 'SUB': return &#123; ...state, count: state.count-- &#125; default: break; &#125;&#125; 使用 immer 之后: 1234567891011const reducer = produce((state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': state.count++ break; case 'SUB': state.count-- default: break; &#125;&#125;) immer 原理解析 immer 源码中，使用了一个 ES6 的新特性 Proxy 对象。Proxy 对象拦截某些操作并实现自定义行为。 immer 中的proxy immer 的做法就是在内部维护一份 state，劫持所有操作，内部来判断是否有变化从而最终决定如何返回。下面这个例子就是一个构造函数，如果将它的实例传入 Proxy 对象作为第一个参数，就能够后面的处理对象中使用其中的方法: 12345678910111213141516171819202122232425class Store &#123; constructor(state) &#123; this.modified = false this.source = state this.copy = null &#125; get(key) &#123; return !this.modified ? return this.source[key]: this.copy[key] &#125; set(key, value) &#123; if (!this.modified) &#123; this.modifing() &#125; return this.copy[key] = value &#125; modifing() &#123; if (this.modified) return this.modified = true // 使用解构实现一层 immutable this.copy = Array.isArray(this.source) ? [...this.source] : &#123; ...this.source &#125; &#125;&#125; 上面这个 Store 构造函数相比源代码省略了很多判断的部分。实例上面有 modified，source，copy 三个属性，有 get，set，modifing 三个方法。modified 作为内置的 flag，判断如何进行设置和返回。 里面最关键的就应该是 modifing 这个函数，如果触发了 setter 并且之前没有改动过的话，就会手动将 modified 这个 flag 设置为 true，并且使用解构实现一层 immutable。 对于 Proxy 的第二个参数，在简版的实现中，我们只是简单做一层转发，任何对元素的读取和写入都转发到 store 实例内部方法去处理。 12345678910const PROXY_FLAG = 'SYMBOL_PROXY_FLAG'const handler = &#123; get(target, key) &#123; // 如果遇到了这个 flag 我们直接返回我们操作的 target return key === PROXY_FLAG ? target : target.get(key) &#125;, set(target, key, value) &#123; return target.set(key, value) &#125;&#125; 这里在 getter 里面加一个 flag 的目的就在于将来从 proxy 对象中获取 store 实例更加方便。 最终我们能够完成这个 produce 函数，创建 store 实例后创建 proxy 实例。然后将创建的 proxy 实例传入第二个函数中去。这样无论在内部做怎样有副作用的事情，最终都会在 store 实例内部将它解决。最终得到了修改之后的 proxy 对象，而 proxy 对象内部已经维护了两份 state ，通过判断 modified 的值来确定究竟返回哪一份。 1234567891011 function produce(state, producer) &#123; const store = new Store(state) const proxy = new Proxy(store, handler) // 执行我们传入的 producer 函数，我们实际操作的都是 proxy 实例，所有有副作用的操作都会在 proxy 内部进行判断，是否最终要对 store 进行改动。 producer(proxy) // 处理完成之后，通过 flag 拿到 store 实例 const newState = proxy[PROXY_FLAG] return newState.modified ? newState.copy : newState.source&#125; 这样，一个分割成 Store 构造函数，handler 处理对象和 produce 处理 state 这三个模块的最简版就完成了，将它们组合起来就是一个最最最 tiny 版的 immer ，里面去除了很多不必要的校验和冗余的变量。但真正的 immer 内部也有其他的功能，例如上面提到的深层嵌套对象的结构化共享等等。 当然，Proxy 作为一个新的 API，并不是所有环境都支持，Proxy 也无法 polyfill，所以 immer 在不支持 Proxy 的环境中，使用 Object.defineProperty 来进行一个兼容。 参考资料: immer.js: 也许更适合你的immutable js库 官方文档","pubDate":"Mon, 06 Apr 2020 06:21:00 GMT","guid":"//sysy.site/2020/04/06/immer/","category":"+ immer"},{"title":"Markdown图片插入","link":"//sysy.site/2020/03/29/tuchuang/","description":"在使用 markdown 写文章时，会遇到要插入图片，markdown 本身是不支持图片直接插入，只能通过 ![]() 的方式插入。 插入的图片路径有两种方式，一种是相对路径(相对于文档所在位置)，一种是绝对路径，如果使用相对路径，有一天不小心改动了图片的在本地的位置，这个图就会挂掉，为了解决这个问题一般使用绝对路径，先把图片上传到图床，然后会生成一个 url，在 markdown 中插入生成的 url，就可以显示图片了。 这里我选用七牛云的图床 第一步: 先去官网注册认证 官网地址: https://www.qiniu.com 注册认证后有10G永久免费空间，每月10G国内和10G国外流量。","pubDate":"Sun, 29 Mar 2020 11:30:00 GMT","guid":"//sysy.site/2020/03/29/tuchuang/","category":"Markdown"},{"title":"快速入门 Markdown 语法","link":"//sysy.site/2020/03/29/markdown-yufa/","description":"前言 Markdown 是一种轻量级标记语言，它使人们使用纯文本格式编写文档，不需要跟 HTML 一样关注标签使用，只需要专注写文档即可，本文就带大家快速入门 Markdown。 在开始之间，首先推荐几个编写 markdown 语法的工具，毕竟古人说的好，预先善其事，必先利其器。有一款出色的编辑器还是能让人事半功倍。 1、Typora 下载地址: https://www.typora.io Mac，Windows，Linux 都支持下载，笔者也在用这款编辑器，超好用！！！","pubDate":"Sun, 29 Mar 2020 06:24:00 GMT","guid":"//sysy.site/2020/03/29/markdown-yufa/","category":"+ Markdown"},{"title":"前端组件库及工具集合","link":"//sysy.site/2020/03/28/web-ui-utils/","description":"一、PC 端 UI 框架 Ant Design 官网地址: https://ant.design/docs/react/introduce-cn GitHub 地址: https://github.com/ant-design/ant-design 阿里旗下蚂蚁金服基于 React 开源的 UI 组件库，企业级中后台直接用它就完事，组件齐全，例子较多，使用简单，估计已经是很多公司的标配了，我公司之前使用，后来转公司内部 UI 组件库了，转的时候还比较难，毕竟 Ant Design 已经发布这么久了，经过很多开发者的建议(最近又新发布了 4.0版本，增加了许多新特性)，功能齐全，而我司的还是个新新的 UI 框架，坑嘛，你懂的！","pubDate":"Sat, 28 Mar 2020 05:29:00 GMT","guid":"//sysy.site/2020/03/28/web-ui-utils/","category":"工具"},{"title":"JS 数组扁平化 (flatten)","link":"//sysy.site/2020/03/21/js-arrayflatten/","description":"前言​ 数组是 JS 中使用评率仅次于对象的数据结构，官方提供了诸多 API (比如：push，pop，shift，unshift ….)，今天我们来谈谈如何扁平化数组。 顾名思义，扁平化数组就是将一些嵌套的多维数组转成一维数组。 我们以一个例子贯穿全文: 1const array = [1, 2, [3, 4, [5, 6], [7, 8], [9]], 10] 一、ES10 中提供的数组扁平化方法 — flat flat 方法会按照一个可指定的深度进行递归遍历数组，并将所有遍历到的元素合并为一个新的数组返回。 语法1const newArray = arr.flat([depth]) 注意：dpeth 参数是可选的, 指定要提取嵌套数组的结构深度，默认值为 1 123const result = array.flat(Infinity) // 当参数为 Infinity 时代表，递归任意深度的嵌套数组console.log(result) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","pubDate":"Sat, 21 Mar 2020 10:15:00 GMT","guid":"//sysy.site/2020/03/21/js-arrayflatten/","category":"javascript,js-array"},{"title":"CSS 变量(variable) -- 实战篇","link":"//sysy.site/2020/03/20/css-variable-2/","description":"一、 网站换肤1、实现网站换肤功能，一般最先想到的是用全局 class 控制样式切换缺点：全局控制 CSS，在项目不大，换肤样式不多的情况下，还能勉强够用。但是换肤样式很多的话，代码会非常臃肿，不利于维护。2、通过 js 来切换引入 CSS 样式的 href 属性值，来达到样式切换的目的。缺点：使用 js 改变 href 属性会带来加载延迟(样式文件越大，加载越久)。3、使用 js 修改 css 变量值来达到换肤效果。 今天我们要说的就是第三种, 使用 js 修改 css 变量值来达到换肤效果","pubDate":"Fri, 20 Mar 2020 13:31:00 GMT","guid":"//sysy.site/2020/03/20/css-variable-2/","category":"+ css"},{"title":"CSS 变量(variable) -- 基础篇","link":"//sysy.site/2020/03/19/css-variable-1/","description":"前言​ css 变量可以让你不使用任何预处理器 (less, sass, stylus)，不需要通过任何工具预处理，可以原生在浏览器中使用变量 一、变量的声明​ 声明变量的时候，变量名前要加两根连字符 (–)。​123:root&#123; --bg-color: #f40;&#125; ​ 上面代码中，声明了一个css变量，你可能会问，为什么官方要选择两根连字符表示变量？因为 $bg-color 被 sass 用掉了，@bg-color 被 less 用掉了，所以官方为了不产生冲突，css 声明变量改用两根连字符了。","pubDate":"Thu, 19 Mar 2020 13:09:00 GMT","guid":"//sysy.site/2020/03/19/css-variable-1/","category":"css"},{"title":"32个js代码小技巧","link":"//sysy.site/2020/03/15/js-daimapianduan/","description":"1、生成长度为 10 的随机 ID 1let id = Math.random().toString(36).slice(2) // \"z29mwr6neu\"","pubDate":"Sun, 15 Mar 2020 07:12:00 GMT","guid":"//sysy.site/2020/03/15/js-daimapianduan/","category":"javascript,js技巧"}]}